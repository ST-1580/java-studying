# Java course

* **BinarySearch** <ol>
  <li>Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве. </li>
  <li>На вход подается целое число x и массив целых чисел <code>a</code>, отсортированный по невозрастанию. Требуется найти минимальное значение индекса <code>i</code>, при котором <code>a[i] <= x</code>. </li>
  <li>Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара. </li>
  <li>Интерфейс программы. 
    <ul>
      <li>Имя основного класса — <code>BinarySearch</code>.</li>
      <li>Первый аргумент командной строки — число <code>x</code>.</li>
      <li>Последующие аргументы командной строки — элементы массива <code>a</code>.</li> 
    </ul>
  </li>
  <li>Пример запуска: <code>java BinarySearch 3 5 4 3 2 1</code>. Ожидаемый результат: <code>2</code>. </li>
</ol>

* **ExpressionParser** <ol>
  <li>Разработайте классы <code>Const, Variable, Add, Subtract, Multiply, Divide</code> для вычисления выражений с одной переменной в типе <code>int</code>.</li>
  <li>Классы должны позволять составлять выражения вида:<br>
   <code>new Subtract(new Multiply(new Const(2), new Variable("x")), new Const(3)).evaluate(5)</code><br>
    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу <code>evaluate</code> (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число <code>7</code>.</li>
  <li>Метод <code>toString</code> должен выдавать запись выражения в полноскобочной форме. Например,<br>
      <code>new Subtract(new Multiply(new Const(2), new Variable("x")), new Const(3)).toString()</code><br>
      должен выдавать <code>((2 * x) - 3)</code>.</li>
  <li>Метод <code>toMiniString</code> должен выдавать выражение с минимальным числом скобок. Например,<br>
    <code>new Subtract(new Multiply(new Const(2), new Variable("x")), new Const(3)).toMiniString()</code><br>
      должен выдавать <code>2 * x - 3</code>.</li>
  <li>Реализуйте метод <code>equals</code>, проверяющий, что два выражения совпадают. Например,<br>
    <code>new Multiply(new Const(2), new Variable("x")).equals(new Multiply(new Const(2), new Variable("x")))</code><br>
    должно выдавать <code>true</code>, а<br>
    <code>new Multiply(new Const(2), new Variable("x")).equals(new Multiply(new Variable("x"), new Const(2)))</code><br>   
    должно выдавать <code>false</code>.</li>
  <li>Для тестирования программы должен быть создан класс <code>Main</code>, который вычисляет значение выражения<br> <code>x * x − 2 * x + 1</code>, для <code>x</code>, заданного в командной строке.</li>
    <li>При выполнении задания следует обратить внимание на:
        <ul>
        <li>Выделение общего интерфейса создаваемых классов.</li>
        <li>Выделение абстрактного базового класса для бинарных операций.</li>
        </ul>
        </li> 
</ol>

* **ExpressionParserAdvanced** <ol>
  <li>Доработайте предыдущее домашнее задание, так что бы выражение строилось по записи вида<br>
    <code>x * (x - 2) * x + 1</code></li>
  <li>В записи выражения могут встречаться: умножение <code>*</code>, деление <code>/</code>, сложение <code>+</code>, вычитание <code>-</code>, унарный минус <code>-</code>, целочисленные константы (в десятичной системе счисления, которые помещаются в 32-битный знаковый целочисленный тип), круглые скобки, переменные <code>x</code> и произвольное число пробельных символов в любом месте (но не внутри констант).</li>
  <li>Приоритет операторов, начиная с наивысшего
    <ul>
      <li>унарный минус</li>
      <li>умножение и деление</li>
      <li>сложение и вычитание</li>
    </ul>
  </li>
  <li>Разбор выражений рекомендуется производить методом рекурсивного спуска. Алгоритм должен работать за линейное время.</li> 
  <li>Добавьте в программу вычисляющую выражения обработку ошибок, в том числе:
    <ul>
      <li>ошибки разбора выражений>/li>
      <li>ошибки вычисления выражений</li>
    </ul>
  </li>
  <li>Для выражения <code>1000000 * x * x * x * x * x / (x - 1)</code> вывод программы должен иметь следующий вид:
    <table>
      <tr>
        <th><code>x</code></th>
        <th><code>f</code></th>
      </tr>
      <tr>
        <td><code>0</code></td>
        <td><code>0</code></td>
      </tr>
      <tr>
        <td><code>1</code></td>
        <td><code>division by zero</code></td>
      </tr>
      <tr>
        <td><code>2</code></td>
        <td><code>32000000</code></td>
      </tr>
      <tr>
        <td><code>3</code></td>
        <td><code>121500000</code></td>
      </tr>
      <tr>
        <td><code>4</code></td>
        <td><code>341333333</code></td>
      </tr>
      <tr>
        <td><code>5</code></td>
        <td><code>overflow</code></td>
      </tr>
      <tr>
        <td><code>6</code></td>
        <td><code>overflow</code></td>
      </tr>
      <tr>
        <td><code>7</code></td>
        <td><code>overflow</code></td>
      </tr>
      <tr>
        <td><code>8</code></td>
        <td><code>overflow</code></td>
      </tr>
      <tr>
        <td><code>9</code></td>
        <td><code>overflow</code></td>
      </tr>
      <tr>
        <td><code>10</code></td>
        <td><code>overflow</code></td>
      </tr>
    </table>
    Результат <code>division by zero (overflow)</code> означает, что в процессе вычисления произошло деление на ноль (переполнение).</li>
    <li>При выполнении задания следует обратить внимание на дизайн и обработку исключений.</li>
    <li>Человеко-читаемые сообщения об ошибках должны выводится на консоль.</li>
    <li>Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).</li> 
</ol>

* **GenericParser** <ol>
     <li>Добавьте в программу разбирающую и вычисляющую выражения поддержку различных типов.<br>
        Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:
        <table>
          <tr>
            <th>Опция</th>
            <th>Тип</th>
          </tr>
          <tr>
            <td><code>-i</code></td>
            <td><code>int</code></td>
          </tr>
          <tr>
            <td><code>-d</code></td>
            <td><code>double</code></td>
          </tr>
          <tr>
            <td><code>-bi</code></td>
            <td><code>BigInteger</code></td>
          </tr>
       </table>
       Вторым аргументом командной строки программа должна принимать выражение для вычисления.</li>
    <li>При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.</li>   
</ol>

* **MdParser** <ol>
  <li>Разработайте набор классов для текстовой разметки.</li>
  <li>Класс <code>Paragraph</code> может содержать произвольное число других элементов разметки и текстовых элементов.</li>
  <li>Класс <code>Text</code> – текстовый элемент.</li>
  <li>Классы разметки <code>Emphasis, Strong, Strikeout</code> – выделение, сильное выделение и зачеркивание. Элементы разметки могут содержать произвольное число других элементов разметки и текстовых элементов.</li>
  <li>Все классы должны реализовывать метод <code>toMarkdown(StringBuilder)</code>, которой должен генерировать Markdown-разметку по следующим правилам:
    <ul>
      <li>текстовые элементы выводятся как есть</li>
    <li>выделенный текст окружается символами '*'</li>
    <li>сильно выделенный текст окружается символами '__'</li>
    <li>зачеркнутый текст окружается символами '~'</li> 
    </ul>
  </li>
  <li>Следующий код должен успешно компилироваться:
    <pre>Paragraph paragraph = new Paragraph(List.of(
        new Strong(List.of(
            new Text("1"),
            new Strikeout(List.of(
                new Text("2"),
                new Emphasis(List.of(
                    new Text("3"),
                    new Text("4")
                )),
                new Text("5")
            )),
            new Text("6")
        ))
    ));</pre>
    Вызов <code>paragraph.toMakdown(new StringBuilder())</code> должен заполнять переданный <code>StringBuilder</code> следующим содержимым:<br>
    <code>__1~2*34*5~6__</code></li>
  <li>Разработанные классы должны находиться в пакете <code>markup</code></li> 
</ol>

* **MdToHtmlParser** <ol>
  <li>Разработайте конвертер из Markdown-разметки в HTML.</li>
  <li>Конвертер должен поддерживать следующие возможности:
    <ul>
      <li>Абзацы текста разделяются пустыми строками.</li>
      <li>Элементы строчной разметки: выделение (* или _), сильное выделение (** или __), зачеркивание (--), код (`)</li>
      <li>Заголовки (# * уровень заголовка)</li>
    </ul>
  </li>
  <li>Конвертер должен называться Md2Html и принимать два аргумента: название входного файла с Markdown-разметкой и название выходного файла c HTML-разметкой. Оба файла должны иметь кодировку UTF-8.</li>
  <li><a href="http://www.kgeorgiy.info/courses/prog-intro/homeworks.html#homework-13">Пример</a></li>
</ol>

* **MyScanner** <ol>
  <li>Реализуйте свой аналог класса <code>Scanner</code> на основе <code>Reader</code>.</li>
  <li>Код, управляющий чтением должен быть общим.</li>
  <li>Код, выделяющий числа и слова должен быть общим.</li>
  <li>При реализации блочного чтения обратите внимание на слова/числа, пересекающие границы блоков, особенно — больше одного раза.</li>
</ol>

* **Queues** <ol>
   <li>Найдите инвариант структуры данных «очередь». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит <code>null</code>.</li>
  <li>Реализуйте класс <code>ArrayQueue</code>, представляющие циклическую очередь с применением массива.<br> 
    Должны быть реализованы следующие функции (процедуры) / методы:
    <ul>
      <li><code>enqueue</code> – добавить элемент в очередь</li>
        <li><code>element</code> – первый элемент в очереди</li>
        <li><code>dequeue</code> – удалить и вернуть первый элемент в очереди</li>
        <li><code>size</code> – текущий размер очереди</li>
        <li><code>isEmpty</code> – является ли очередь пустой</li>
        <li><code>clear</code> – удалить все элементы из очереди</li>
    </ul>
    Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.<br>
    Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.</li>   
  <li>Определите интерфейс очереди <code>Queue</code> и опишите его контракт.</li>
  <li>Реализуйте класс <code>LinkedQueue</code> — очередь на связном списке.</li>
  <li>Выделите общие части классов <code>LinkedQueue</code> и <code>ArrayQueue</code> в базовый класс <code>AbstractQueue</code>.</li>
</ol>

* **TicTacToe** <ol>
  <li>Реализуйте игру <a href="https://en.wikipedia.org/wiki/M,n,k-game">m, n, k</a>.</li>
  <li>Добавьте обработку ошибок ввода пользователя.</li>
  <li>Проверку выигрыша нужно производить за O(k).</li>
  <li>Предотвратите жульничество: у игрока не должно быть возможности достать <code>Board</code> из <code>Position</code>.</li>   
</ol>
